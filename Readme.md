# Project

Project is essentially a template for a solution. The intent was to keep source files, support files and build files organized and separated. Its basic concepts date back to 1995 (small portions of the Util library--mostly the string and conversion functions--also date back to that time.) One overriding principle has been to ensure that unit testing is easier *and* uses the same compilation as the application. 

> A large project I worked on in 2015 reinforced this view; in order to work with the Visual Studio testing framework, most of the application was recompiled as a DLL. While this worked, some code paths were different between the DLL and the application (until I fixed it, the projects had mismatched compiler settings, so the code *was* different between the two.) It also doubled the time of an already very long build.

> One advantage of having a single solution which builds so many projects is that if a library changes in a way which would render a high level project uncompilable, this is caught immediately.

A second principle is to keep temporary objects and third party code out of the project code folders. Among other things, this simplifies searching source code. It also greatly reduces accidentally checking in temporary objects (such as those generated by Qt.) Finally, it makes doing compares much easier.

> I've worked on several projects where doing a clean build required that the entire project be deleted, or renamed, and then refetched from source control. A few of these projects were so big, this would take several minutes.

A third principle is reuse. Even code highly specific to an application may have a case for reuse. For example, a GUI application may have a command-line only counterpart. Another oft-ignored reason for reuse is experimentation. 

> I recently worked on a project where there was a significant delay when loading a different set of image assets. This reuse philosophy allowed me to test various scenarios to pinpoint the causes for the delays. (I assumed it was the actual reading and decoding the PNG files, but it was mostly creating OpenGL objects, which required writing gigabytes of data to memory.)

A fourth principle of this general approach is that it helps understand the layers of the solution. Circling back to unit testing, one complaint, especially with embedded systems, is that code can't be tested. Yet, quite often in can be by separating platform and/or hardware specific code from the rest. This works on both sides; you can write a "mock" hardware layer and you can write test code which tests the hardware layer (even it not automated.)

Note that this solution is currently Visual Studio oriented. At one point this was used with Visual Studio, cmake (CLion) and Qt Creator. The latter two were removed as they got out of sync. There is a chance the cmake/CLion files have returned, but I haven't yet had the need nor sufficient boredom to do so.

### API Documentation

The libraries tend to use doxygen style comments in the headers (a few files still use XML documentation comments.) An attempt to compile the help files hasn't been made in years since the compiled help wasn't found to be  useful and was constantly out-of-date. As a result, it's not clear if the doxygen comments are entirely, syntactically valid. Visual Studio 2019 has some support for doxygen, so may flag errors.



- [Solution Layout](Docs/SolutionLayout.md)
- [Visual Studio Warnings](Docs/VisualStudioWarnings.txt)


